# Задача №1. Угадай число

## Оглавление  
[1. Описание задачи](#1-описание-задачи)

[2. Цель задачи](#2-цель-задачи)

[3. Краткая информация об используемом алгоритме](#3-краткая-информация-об-используемом-алгоритме)

[4. Код и описание](#4-код-и-описание)

[5. Выводы](#5-выводы)

[6. Источники](#6-источники)

[7. Оценка](#7-оценка)

### 1. Описание задачи:    
&nbsp; &nbsp; &nbsp; &nbsp;Угадать загаданное компьютером число за минимальное число попыток.

:arrow_up:[к оглавлению](#оглавление)

### 2. Цель задачи:
&nbsp; &nbsp; &nbsp; &nbsp;Написать программу, которая угадывает число за минимальное число попыток.

&nbsp; &nbsp; &nbsp; &nbsp;**Условия задачи:**  

- Компьютер загадывает целое число от 1 до 100, и нам его нужно угадать. Под «угадать» подразумевается «написать программу, которая угадывает число».
- Алгоритм учитывает информацию о том, больше или меньше случайное число нужного нам числа.
- Представлен шаблон baseline из скринкаста.
- Написать свою функцию, которая будет справляться с угадыванием меньше чем за 20 попыток.


&nbsp; &nbsp; &nbsp; &nbsp;**Метрика качества:** 

&nbsp; &nbsp; &nbsp; &nbsp;Результаты оцениваются по среднему количеству попыток при 1000 повторений. Необходимо добиться минимального количества попыток, но не более 20.

&nbsp; &nbsp; &nbsp; &nbsp;**Что практикуем:**   

&nbsp; &nbsp; &nbsp; &nbsp;Учимся писать хороший код на python

:arrow_up:[к оглавлению](#оглавление)

### 3. Краткая информация об используемом алгоритме:

&nbsp; &nbsp; &nbsp; &nbsp;Бинарный поиск - это алгоритм, который делит диапазон поиска пополам на каждом шаге. Это означает, что мы каждый раз уменьшаем количество возможных вариантов вдвое.

&nbsp; &nbsp; &nbsp; &nbsp;Представим, что у нас есть список из $n$ элементов. Если мы каждый раз делим его пополам, то после первого шага у нас останется $\frac{n}{2}$ элементов, после второго шага - $\frac{n}{4}$, после третьего - $\frac{n}{8}$, и так далее. Мы продолжаем делить на 2, пока не останется один элемент. Количество шагов, которое потребуется, чтобы дойти до этого момента, будет равно количеству раз, которое мы поделили $n$ пополам.

&nbsp; &nbsp; &nbsp; &nbsp;Если мы обозначим количество шагов как $k$, то после $k$ шагов у нас останется $\frac{n}{2^k}$ элементов. Когда останется один элемент, $\frac{n}{2^к} = 1$. Если решить это уравнение относительно $k$, то получим $k=log_2​(n)$.

&nbsp; &nbsp; &nbsp; &nbsp;Таким образом, формула $log_2​(n)$ в контексте бинарного поиска отражает максимальное количество шагов, которое потребуется для поиска элемента в отсортированном списке из $n$ элементов. 

&nbsp; &nbsp; &nbsp; &nbsp;В контексте нашей задачи, бинарный поиск позволит найти число менее чем за 20 попыток. Бинарный поиск работает, делая середину диапазона (от low до high или от 1 до 100 в нашем случае) следующим предполагаемым числом. Если предполагаемое число не равно загаданному числу, диапазон сужается вдвое. 

&nbsp; &nbsp; &nbsp; &nbsp;Это происходит потому, что мы знаем, что загаданное число либо меньше, либо больше предполагаемого числа. Таким образом, каждая попытка сужает диапазон вдвое, что позволяет быстро приблизиться к загаданному числу.

&nbsp; &nbsp; &nbsp; &nbsp;Поскольку диапазон чисел от 1 до 100 включает 100 чисел, бинарный поиск будет требовать не более $log_2​(100)$ попыток, чтобы найти число. $log_2​(100) = 7$ , что в свою очередь меньше 20 и удовлетворяет условию нашей задачи. 

:arrow_up:[к оглавлению](#оглавление)

### 4. Код и описание:
&nbsp; &nbsp; &nbsp; &nbsp;Эта строка импортирует библиотеку numpy, которая предоставляет функции для работы с числами.

```
import numpy as np
```

&nbsp; &nbsp; &nbsp; &nbsp;Здесь генерируется случайное число в диапазоне от 1 до 100 (включительно). Затем происходит его сохранение в переменной number.

```
number = np.random.randint(1, 101)
```

&nbsp; &nbsp; &nbsp; &nbsp;Функция check принимает число mid и сравнивает его с загаданным числом. 
- Если mid меньше загаданного числа, функция возвращает 1.
- Если mid больше загаданного числа, функция возвращает -1. 
- Если mid равно загаданному числу, функция возвращает 0.

&nbsp; &nbsp; &nbsp; &nbsp;Эти три значения (1, 0, -1) помогают алгоритму бинарного поиска определить, в каком направлении продолжать поиск: в большем диапазоне, в меньшем диапазоне или прекратить поиск, так как число найдено. Это обеспечивает эффективность бинарного поиска, позволяя быстро найти загаданное число.


```
def check(mid):
    if mid < number:
        return 1
    elif mid > number:
        return -1
    else:
        return 0_
```

&nbsp; &nbsp; &nbsp; &nbsp;Функция guess_number инициализирует переменные low, high и count. 

&nbsp; &nbsp; &nbsp; &nbsp;low и high определяют диапазон чисел, в котором мы ищем загаданное число. 

&nbsp; &nbsp; &nbsp; &nbsp;count считает количество попыток, которые мы сделали, чтобы угадать число.

```
def guess_number():
    low = 1
    high = 100
    count = 0
```

&nbsp; &nbsp; &nbsp; &nbsp;В этом цикле мы берем среднее значение между low и high и сохраняем его в mid. Цикл выполняется, пока нижняя граница low не превысит верхнюю границу high. Это условие гарантирует, что мы не выйдем за пределы диапазона чисел, в котором ищем загаданное число.

&nbsp; &nbsp; &nbsp; &nbsp;Формула "mid = (low + high) // 2" является частью алгоритма бинарного поиска. В ней мы находим среднее значение между low и high. Это делается для того, чтобы сократить диапазон поиска вдвое на каждом шаге. Если загаданное число больше mid, то оно находится в верхней половине диапазона. Если оно меньше mid, то оно находится в нижней половине. Таким образом, выбирая mid как середину диапазона, мы сокращаем область поиска.

&nbsp; &nbsp; &nbsp; &nbsp;Затем мы увеличиваем count на 1, так как мы сделали еще одну попытку угадать число.

```
while low <= high:
    mid = (low + high) // 2
    count += 1
```

&nbsp; &nbsp; &nbsp; &nbsp;Здесь мы вызываем функцию check с mid в качестве аргумента и сохраняем результат в result.

```
result = check(mid)
```

&nbsp; &nbsp; &nbsp; &nbsp;Если result равен -1, это означает, что mid больше загаданного числа, поэтому мы уменьшаем high до mid - 1. 

&nbsp; &nbsp; &nbsp; &nbsp;Если result равен 1, это означает, что mid меньше загаданного числа, поэтому мы увеличиваем low до mid + 1. 

&nbsp; &nbsp; &nbsp; &nbsp;Если result равен 0, это означает, что мы угадали число, и функция возвращает mid и count.

```
if result == -1:
    high = mid - 1
elif result == 1:
    low = mid + 1
else:
    return mid, count_
```

&nbsp; &nbsp; &nbsp; &nbsp;Здесь мы вызываем функцию guess_number, сохраняем результаты в number и count, а затем выводим их.

```
number, count = guess_number()
print(f"Загаданное число: {number}, количество попыток: {count}")
```

:arrow_up:[к оглавлению](#оглавление)

### 5. Выводы:  
&nbsp; &nbsp; &nbsp; &nbsp;Бинарный поиск является эффективным алгоритмом для решения нашей задачи.

:arrow_up:[к оглавлению](#оглавление)

### 6. Источники: 
&nbsp; &nbsp; &nbsp; &nbsp;Перечень источников использованных в написании теории:

&nbsp; &nbsp; &nbsp; &nbsp; 1. https://blog.skillfactory.ru/glossary/binarnyj-poisk/

&nbsp; &nbsp; &nbsp; &nbsp; 2. https://ru.hexlet.io/courses/basic-algorithms/lessons/binary-search/theory_unit

&nbsp; &nbsp; &nbsp; &nbsp; 3. https://programmyfree.ru/chto-takoe-binarnyy-poisk-osnovnye-printsipy-i-primenenie/

&nbsp; &nbsp; &nbsp; &nbsp; 4. https://otus.ru/journal/binarnyj-poisk-opisanie-i-princip-realizacii-v-programmirovanii/

&nbsp; &nbsp; &nbsp; &nbsp; 5. https://habr.com/ru/articles/195996/

&nbsp; &nbsp; &nbsp; &nbsp; 6. https://stackoverflow.com/questions/8185079/how-to-calculate-binary-search-complexity

&nbsp; &nbsp; &nbsp; &nbsp; 7. https://en.wikipedia.org/wiki/Binary_search_algorithm

&nbsp; &nbsp; &nbsp; &nbsp; 8. https://www.geeksforgeeks.org/complexity-analysis-of-binary-search/

:arrow_up:[к оглавлению](#оглавление)

### 7. Оценка:
&nbsp; &nbsp; &nbsp; &nbsp;Если информация по этому проекту покажется вам интересной или полезной, то я буду очень вам благодарен, если отметите репозиторий и профиль ⭐️⭐️⭐️

:arrow_up:[к оглавлению](#оглавление)
